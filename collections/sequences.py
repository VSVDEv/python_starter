"""
Некоторые итерабельные объекты обладают определёнными общими свойствами.

Итерабельные объекты, которые поддерживают эффективный доступ к элементам
с использованием целочисленных индексов через специальный метод __getitem__()
и поддерживают метод __len__(), который возвращает количество элеметов,
называются последовательностями.

Уже были рассмотрены три типа данных, которые являются последовательностями.
"""

# Список
my_list = [1, 2, 3]

# Итерирование
print('Iterating:')
for element in my_list:
    print(element)

print()

# Получение доступа к элементам при помощи целочисленных ключей (индексация)
print('Indexing:')
print(my_list[0])
print(my_list[2])
print(my_list[-1])

print()

# Длина последовательности
print('Length:', len(my_list))





"""
Некоторые итерабельные объекты обладают определёнными общими свойствами.

Итерабельные объекты, которые поддерживают эффективный доступ к элементам
с использованием целочисленных индексов через специальный метод __getitem__()
и поддерживают метод __len__(), который возвращает количество элеметов,
называются последовательностями.

Уже были рассмотрены три типа данных, которые являются последовательностями.
"""

# Строка
string = "Lorem ipsum dolor sit amet, consectetur adipisicing elit."

# Итерирование
print('Iterating:')
for character in string:
    print(character)

print()

# Получение доступа к элементам при помощи целочисленных ключей (индексация)
print('Indexing:')
print(string[0])
print(string[2])
print(string[-1])

print()

# Длина последовательности
print('Length:', len(string))


"""
Некоторые итерабельные объекты обладают определёнными общими свойствами.

Итерабельные объекты, которые поддерживают эффективный доступ к элементам
с использованием целочисленных индексов через специальный метод __getitem__()
и поддерживают метод __len__(), который возвращает количество элеметов,
называются последовательностями.

Уже были рассмотрены три типа данных, которые являются последовательностями.
"""

# Список
my_range = range(10)

# Итерирование
print('Iterating:')
for element in my_range:
    print(element)

print()

# Получение доступа к элементам при помощи целочисленных ключей (индексация)
print('Indexing:')
print(my_range[0])
print(my_range[2])
print(my_range[-1])

print()

# Длина последовательности
print('Length:', len(my_range))


"""
Большинство последовательностей поддерживают операции
проверки вхождения элемента in и not in.

Для поддержки данной операции необходимо реализовать
специальный метод __contains__
"""

# Список
my_list = [1, 3, 5, 7]
print(3 in my_list)
print(9 in my_list)
print(18 not in my_list)

print()


# Диапазон
my_range = range(2, 10)
print(3 in my_range)
print(5 not in my_range)

print()


# Для строк эта операция проверяет вхождение подстроки
print('ips' in 'Lorem ipsum dolor sit amet.')

print()


# Реализация поддержки операции
class Container(object):
    def __contains__(self, element):
        return element == 3


container = Container()
print(3 in container)
print(5 in container)

"""
Функции min, max и sum работают для любых итерабельных объектов, которые
содержат в себе сравнимые объекты или числа соответственно.
"""

my_list = [1, 3, 5, 2, 0, -3, 17]
print(min(my_list))
print(max(my_list))
print(sum(my_list))


"""
Многие последовательности реализуют метод index, который позволяет
получить индекс объекта в последовательности. Если объект не
найден, возникает исключение ValueError.
"""


my_list = [1, 4, 2, 0, -3, 1, 3, 2]
value = 2

# Поиск с начала последовательности
print(my_list.index(value))

# Поиск с третьего элемента
print(my_list.index(value, 3))

# Поиск с третьего до шестого
print(my_list.index(value, 3, 6))  # ValueError


"""
Также многие последовательности реализуют метод count,
который возвращает количество вхождений элемента в последовательность.
"""

text = '''Lorem ipsum dolor sit amet, consectetur adipisicing elit. Temporibus
doloremque facere blanditiis, dolores porro a autem facilis repudiandae
ea commodi quidem, maxime aliquid aut quam similique? Ea magni accusantium 
nam excepturi dignissimos.'''

print(text.count('o'))


"""
Для изменяемых последовательностей характерны операции присваивания и удаления
элементов по индексу или срезу. Они реализуются при помощи специальных
методов __setitem__ и __delitem__.
"""


my_list = [1, 4, 3, 5, 7]
print(my_list)

my_list[0] = 10
print(my_list)

my_list[3:] = range(10)
print(my_list)

del my_list[0]
print(my_list)

del my_list[:]
print(my_list)


"""
Примеры других общих для изменяемых последовательностей методов.
"""


sequence = [1, 3, 5]
print(sequence)

# Добавление элемента в конец
sequence.append(3)  # sequence[len(sequence):] = [3]
print(sequence)

# Добавление в конец элементов из итерабельного объекта
sequence.extend(range(3))  # sequence[len(sequence):] = range(3)
print(sequence)

# Добавление элемента по индексу
sequence.insert(1, 8)  # sequence[1:1] = [8]
print(sequence)

# Удаление первого вхождения элемента
sequence.remove(3)  # del sequence[sequence.index(3)]
print(sequence)

# Удаление последнего элемента
sequence.pop()  # del sequence[-1]
print(sequence)

# Удаление элемента по индексу
sequence.pop(4)  # del sequence[4]
print(sequence)

# Удаление всех элементов
sequence.clear()  # del sequence[:]
print(sequence)


"""
Многие последовательности реализуют метод index, который позволяет
получить индекс объекта в последовательности. Если объект не
найден, возникает исключение ValueError.
"""


my_list = [1, 4, 2, 0, -3, 1, 3, 2]
value = 2

# Поиск с начала последовательности
print(my_list.index(value))

# Поиск с третьего элемента
print(my_list.index(value, 3))

# Поиск с третьего до шестого
print(my_list.index(value, 3, 6))  # ValueError



"""
Списковые включения позволяют лаконично описывать списки, которые строятся
по определённым выражениям, фильтровать их и применять функции к их элементам.
Их синтаксис аналогичен синтаксису выражений-генераторов, но обрамляется
квадратными скобками (хотя вообще корректнее говорить, что синтаксис
выражений-генераторов аналогичен синтаксису списковых включений, так как
они появились в языке значительно позже списковых включений).
"""


# Создание списка
my_list = [x ** 2 for x in range(10)]
print(my_list)

# Выбор чётных и нечётных чисел из списка
print([x for x in my_list if x % 2 == 0])
print([x for x in my_list if x % 2 == 1])


"""
Метод sort() сортирует список, модифицируя его. Также существует встроенная
функция sorted, которая сортирует любой итерабельный объект, не модифицируя
его, и возвращает список.
"""

my_list = [4, 3, 2, 0, 17, -5, 3]
list_copy = my_list[:]
print(my_list)

my_list.sort()
print(my_list)

list_copy.sort(reverse=True)
print(list_copy)

print()

string = 'Lorem ipsum dolor sit amet.'
print(string)
sorted_string = sorted(string)
print(sorted_string)
print(''.join(sorted_string))


# Операция умножения часто используется со списками
# для инициализации списка заданным количеством одинаковых элементов
some_list = [0] * 10
print(some_list)

print()


# Операция * конкатенирует неполные копии списков, то есть объекты
# внутри копий не копируются, а сохраняются ссылки на них.
# Об этом следует помнить, когда в списке находятся изменяемые
# объекты, например, другие списки.

# Начинающие программисты на Python часто допускают подобную
# ошибку, когда хотят инициализировать двумерную матрицу при
# помощи списков списков.


def print_matrix(matrix):
    """Функция вывода матрицы"""
    for row in matrix:
        print(' '.join(str(element) for element in row))


# Создание матрицы 5x5 (неправильно)
matrix_done_wrong = [[0] * 5] * 5
# Пока что выводится правильно
print_matrix(matrix_done_wrong)

print()

# Изменение одного элемента
matrix_done_wrong[1][3] = 8
# Изменились соответствующие элементы во всех строках
print_matrix(matrix_done_wrong)

print()


# Это произошло из-за того, что список хранит в себе ссылки
# на объекты. Второй оператор * создал список из ссылок на
# один и тот же список. Правильным было бы использовать
# функцию deepcopy модуля copy (что в данном случае было бы
# неудобно и породило бы много кода, но было бы удобно,
# например, для создания копии уже созданной матрицы) или,
# что является лучшим решением в данном случае, создавать
# каждую строку матрицы отдельно. Проще и лаконичнее всего
# это сделать при помощи спискового включения.


# Создание матрицы 5x5 (правильно)
matrix_done_right = [[0] * 5 for _ in range(5)]
# Вывод
print_matrix(matrix_done_right)

print()

# Изменение одного элемента
matrix_done_right[1][3] = 8
# Только один элемент и изменился
print_matrix(matrix_done_right)



"""
Кортежи – это неизменяемые последовательности, обычно используемые,
чтобы хранить разнотипные данные (или однотипные, но логически
представляющие разные сущности). Представлены классом tuple.
"""

# Пустой кортеж
empty_tuple = ()
print(empty_tuple)

# Кортеж из одного элемента
singleton_tuple = (8,)
print(singleton_tuple)

# Кортеж из нескольких элементов
some_tuple = (3, 2, 1, 8)
print(some_tuple)

# Или, что то же самое
some_tuple = 3, 2, 1, 8
print(some_tuple)

# Список кортежей
coordinates = [(8, 3), (2, 0), (3, 4), (0, 0)]
print(coordinates)

# Кортеж кортежей
triangle = ((0, 0), (4, 0), (0, 3))
print(triangle)



# Переменные, объединённые в кортеж, могут стоять в левой части
# присваивания или заголовке цикла for. Тогда им присваиваются
# соответствующие значения итерабельного объекта.

a, b, c = 1, 2, 3
print(a)
print(b)
print(c)

print()

# В список rest будут помещены оставшиеся элементы последовательности
a, b, *rest = range(10)
print(a)
print(b)
print(rest)

print()

# Поменять местами значения двух переменных
print(a, b)
a, b = b, a
print(a, b)

print()

# Список кортежей
tuples = [(x, y) for x in range(3) for y in range(3)]
# Итерирование списка
for t in tuples:
    print(t)
# Итерирование с распаковкой
for x, y in tuples:
    print(x, y)


# Встроенная функция zip возвращает объект-итератор, возвращающий
# кортежи, состоящие из соответствующих элементов заданных
# последовательностей. Количество элементов, которые возвращает
# итератор, равно длине наименьшей из последовательностей.

nodes = ['node1', 'node2', 'node3']
weights = [1, 7, 5, 5, 9, 3]

for node, weight in zip(nodes, weights):
    print('The weight of node', node, 'is', weight)

# Встроенная функция enumerate возвращает объект-итератор,
# возвращающий пары индексов и значений последовательности
# То есть, поведение enumerate(seq) аналогично
# zip(range(seq), seq))

for index, node in enumerate(nodes):
    print('nodes[{}] = {}'.format(index, node))



# Функция может иметь произвольное количество аргументов. После всех
# позиционных параметров функции или вместо них (но перед теми, которые
# предполагается использовать как именованные) в её сигнатуре можно
# указать специальный аргумент с символом * перед именем. Тогда
# оставшиеся фактические параметры сохраняются в кортеже с этим именем.


def multiply(*numbers):
    result = 1
    for number in numbers:
        result *= number
    return result


print(multiply(2, 3))
print(multiply(1, 9, 7, 8))


# Также существует и обратная возможность. Если при вызове функции
# перед именем итерабельного объекта поставить символ *, то его элементы
# распаковываются в позиционные аргументы.


def print_person(name, age, address):
    print(name, 'is', age, 'years old and lives at', address)


data = [
    ('John', 23, '18 Spring Lane'),
    ('Kate', 18, '20 Victory Str'),
    ('Vasiliy', 20, '323 Green Ave'),
]

for person in data:
    print_person(*person)





"""
Последовательности одинаковых типов можно сравнивать. Сравнения происходят
в лексикографическом порядке: последовательность меньшей длины меньше, чем
последовательность большей длины, если же их длины равны, то результат
сравнения равен результату сравнения первых отличающихся элементов.
"""

print('abc' < 'ab')
print('abc' < 'abcd')

words = ['lorem', 'ipsum', 'dolor', 'sit', 'amet']
print(sorted(words))







